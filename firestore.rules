/**
 * Firestore Security Rules
 *
 * This file implements security rules for the Estate Management application.
 * These rules should be deployed to Firebase Console > Firestore > Rules tab.
 *
 * Rules implemented:
 * - /listings: Public read (active only), authenticated create, owner/admin update/soft-delete
 * - /users/{uid}: Owners can read/write own profile only (no public access)
 * - /images: Listing owner can manage images
 *
 * Key security patterns:
 * - isActive check on listing reads (soft delete awareness)
 * - listedBy.id comparison for ownership (matches domain model)
 * - Role-based access for admins
 * - User document privacy (no public reads)
 */

rules_version = '2';
service cloud.firestore {
  match /databases/{database}/documents {
    
    /**
     * Helper function: Check if user is authenticated
     */
    function isAuthenticated() {
      return request.auth != null;
    }
    
    /**
     * Helper function: Check if user owns the listing
     * Compares request user's UID with listing's listedBy.id field
     */
    function isListingOwner(listing) {
      return request.auth.uid == listing.listedBy.id;
    }

    /**
     * Helper function: Check if listing is active
     * Soft-deleted listings have isActive == false
     */
    function isActiveListing(listing) {
      return listing.isActive != false;
    }
    
    /**
     * Helper function: Check if user is an admin
     * Assumes user document exists at /users/{uid} with role field
     */
    function isAdmin() {
      return get(/databases/$(database)/documents/users/$(request.auth.uid)).data.role == 'admin';
    }
    
    /**
     * Listings collection - /listings/{listingId}
     *
     * Read: Anyone can read active listings (isActive == true)
     * Create: Only authenticated users can create
     * Update: Only listing owner or admins can update
     * Delete: Not allowed (use soft delete by setting isActive = false)
     *
     * Domain model note: Listings use listedBy.id to store owner's UID
     * Soft delete: isActive field set to false, document remains in Firestore
     */
    match /listings/{listingId} {
      // Public read: Anyone can view active listings
      allow read: if isActiveListing(resource.data);

      // Create: Only authenticated users can create new listings
      // Note: Backend enforces listedBy.id, this just requires auth
      allow create: if isAuthenticated();

      // Update: Only owner or admin can modify
      allow update: if isAuthenticated() && 
        (isListingOwner(resource.data) || isAdmin());

      // Soft delete: Owner or admin can set isActive = false
      // Note: Hard delete is not allowed to preserve history
      allow delete: if false;
    }

    /**
     * Nested documents pattern for subcollections (if needed in future)
     */
    match /listings/{listingId}/{document=**} {
      allow read: if isActiveListing(get(/databases/$(database)/documents/listings/$(listingId)).data);
      allow write: if isAuthenticated() && 
        isListingOwner(get(/databases/$(database)/documents/listings/$(listingId)).data);
    }
    
    /**
     * Users collection - /users/{uid}
     *
     * Read: Only the user can read their own document (no public profile reads)
     * Create: User can create their own profile during registration
     * Update: User can update their own profile (except role field - admins only)
     * Delete: Only admins can delete user documents
     *
     * Security:
     * - No public user reads (protects privacy)
     * - Users cannot change their own role (prevents privilege escalation)
     * - Soft delete via deactivateUser() - sets isActive = false
     */
    match /users/{uid} {
      // Private read: Only the user can read their own profile
      allow read: if isAuthenticated() && isOwner(uid);

      // User can create their own profile on registration
      allow create: if isAuthenticated() && isOwner(uid);

      // User can update their own profile, but not the role field
      allow update: if isAuthenticated() && isOwner(uid) && 
        !request.resource.data.diff(resource.data).affectedKeys().hasAny(['role']);

      // Only admins can delete user documents
      allow delete: if isAuthenticated() && isAdmin();
    }

    /**
     * Helper function: Check if user owns the user document (by UID)
     */
    function isOwner(uid) {
      return request.auth.uid == uid;
    }
    
    /**
     * Images collection - /images/{imageId}
     *
     * Note: Images are primarily accessed through listings.
     * This collection stores metadata only if needed.
     *
     * Read: Anyone can read (images are public URLs from Firebase Storage)
     * Create: Authenticated users can upload to their listings
     * Update: Listing owner can update image metadata
     * Delete: Listing owner can delete images for their listings
     */
    match /images/{imageId} {
      allow read: if true;
      allow create: if isAuthenticated();
      allow update: if isAuthenticated() && resource.data.userId == request.auth.uid;
      allow delete: if isAuthenticated() && resource.data.userId == request.auth.uid;
    }
    
    /**
     * Messages collection
     * - Only message participants can read messages
     * - Authenticated users can create messages
     * - Users can only delete their own messages
     */
    match /messages/{messageId} {
      allow read: if isAuthenticated() && (
        request.auth.uid == resource.data.senderId || 
        request.auth.uid == resource.data.recipientId
      );
      allow create: if isAuthenticated() && request.resource.data.senderId == request.auth.uid;
      allow delete: if isAuthenticated() && resource.data.senderId == request.auth.uid;
    }
  }
}

/*
 * HOW TO DEPLOY THESE RULES:
 *
 * 1. Go to Firebase Console (https://console.firebase.google.com/)
 * 2. Select your project
 * 3. Go to Firestore Database > Rules tab
 * 4. Copy and paste the entire rules_version = '2'; ... section
 * 5. Click "Publish"
 *
 * TESTING RULES:
 *
 * Local testing with Firebase Emulator:
 * 1. Install Firebase CLI: npm install -g firebase-tools
 * 2. Start emulator: firebase emulators:start
 * 3. Set VITE_REACT_APP_USE_FIREBASE_EMULATOR=true in .env
 * 4. Test with Firestore Emulator UI (http://localhost:4000)
 *
 * Test scenarios to verify:
 * - Anonymous user: Can read active listings, cannot create/update
 * - Authenticated owner: Can read own profile, create/update own listings
 * - Authenticated non-owner: Cannot update other's listings (FORBIDDEN 403)
 * - Admin user: Can update any listing
 *
 * SECURITY NOTES:
 *
 * 1. Soft Delete Pattern:
 *    - Listings use isActive flag for soft delete
 *    - Documents remain in Firestore (preserves history, references)
 *    - Read rules check isActive == true
 *    - Hard delete disabled to maintain data integrity
 *
 * 2. Admin Verification:
 *    - Current: Reads user.role field from Firestore
 *    - Future improvement: Use Firebase custom claims (faster, more secure)
 *    - Custom claims require Cloud Function to set during user creation
 *
 * 3. Ownership Model:
 *    - Listings: owner stored in listedBy.id field
 *    - Users: ownership implicit in document path (/users/{uid})
 *    - Backend enforces these values (client cannot override)
 *
 * 4. Privacy:
 *    - User profiles are private (only owner can read)
 *    - Public user reads blocked (no profile enumeration)
 *    - Listing data is public (real estate is inherently public)
 *
 * FUTURE IMPROVEMENTS:
 *
 * 1. Use Firebase custom claims for admin role:
 *    ```javascript
 *    function isAdmin() {
 *      return request.auth.token.admin == true;
 *    }
 *    ```
 *
 * 2. Add data validation on write:
 *    ```javascript
 *    allow create: if isAuthenticated() &&
 *      request.resource.data.title is string &&
 *      request.resource.data.rent is number &&
 *      request.resource.data.rent > 0;
 *    ```
 *
 * 3. Implement rate limiting:
 *    - Use Cloud Functions to throttle writes
 *    - Track request.time to implement cooldown
 *
 * 4. Add message collection rules (if needed):
 *    - Only participants can read/write
 *    - Automatic message expiration
 *    - Prevents spam/abuse
 */
